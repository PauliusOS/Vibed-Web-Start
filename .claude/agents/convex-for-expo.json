{
  "_creationTime": 1760313972504.2634,
  "_id": "kn70n5yeq2y8gy593hc2kcvgr17sdq47",
  "authorEmail": "0xpaulius@gmail.com",
  "authorName": "Paulius",
  "categories": [],
  "clerkId": "user_30mlLem6xz7dBn7sqJNMUozNjBR",
  "createdAt": 1760313972508.0,
  "databases": [
    "Convex"
  ],
  "description": "Code Agent for coding with convex on expo framework",
  "frameworks": [
    "Expo"
  ],
  "instructions": "---\nname: agent-convex\ndescription: Best practices for coding with codex with expo\nmodel: inherit\ncolor: blue\n---\n\n# Convex guidelines\n\n## Function guidelines\n\n### New function syntax\n\n- ALWAYS use the new function syntax for Convex functions. For example:\n\n\\`\\`\\`ts\nimport { query } from \"./_generated/server\";\nimport { v } from \"convex/values\";\nexport const f = query({\n  args: {},\n  handler: async (ctx, args) => {\n    // Function body\n  },\n});\n\\`\n\n### Http endpoint syntax\n\n- HTTP endpoints are defined in \\`convex/http.ts\\` and require an \\`httpAction\\` decorator. For example:\n\n\\`\\`\\`ts\nimport { httpRouter } from \"convex/server\";\nimport { httpAction } from \"./_generated/server\";\nconst http = httpRouter();\nhttp.route({\n    path: \"/echo\",\n    method: \"POST\",\n    handler: httpAction(async (ctx, req) => {\n      const body = await req.bytes();\n      return new Response(body, { status: 200 });\n    }),\n});\n\\`\\`\\`\n\n- HTTP endpoints are always registered at the exact path you specify in the \\`path\\` field. For example,\nif you specify \\`/api/someRoute\\`, the endpoint will be registered at \\`/api/someRoute\\`.\n\n### Validators\n\n- Here are the valid Convex types along with their respective validators:\n Convex Type  | TS/JS type  |  Example Usage         | Validator for argument validation and schemas  | Notes\n                                                                              |\n| ----------- | ------------| -----------------------| -----------------------------------------------| ------------------------------------------------------------------------------------------------------------------------\n------------------------------------------------------------------------------|\n| Id          | string      | \\`doc._id\\`              | \\`v.id(tableName)\\`                              |\n                                                                              |\n| Null        | null        | \\`null\\`                 | \\`v.null()\\`                                     | JavaScript's \\`undefined\\` is not a valid Convex value. Functions the return \\`undefined\\` or do not return will return \\`null\\` when called from a client. Use \\`null\\` instead.                             |\n| Int64       | bigint      | \\`3n\\`                   | \\`v.int64()\\`                                    | Int64s only support BigInts between -2^63 and 2^63-1. Convex supports \\`bigint\\`s in most modern browsers.\n                                                                              |\n| Float64     | number      | \\`3.1\\`                  | \\`v.number()\\`                                   | Convex supports all IEEE-754 double-precision floating point numbers (such as NaNs). Inf and NaN are JSON serialized as\nstrings.                                                                      |\n| Boolean     | boolean     | \\`true\\`                 | \\`v.boolean()\\`                                  |\n| String      | string      | \\`\"abc\"\\`                | \\`v.string()\\`                                   | Strings are stored as UTF-8 and must be valid Unicode sequences. Strings must be smaller than the 1MB total size limit w\nhen encoded as UTF-8.                                                         |\n| Bytes       | ArrayBuffer | \\`new ArrayBuffer(8)\\`   | \\`v.bytes()\\`                                    | Convex supports first class bytestrings, passed in as \\`ArrayBuffer\\`s. Bytestrings must be smaller than the 1MB total siz\ne limit for Convex types.                                                     |\n| Array       | Array]      | \\`[1, 3.2, \"abc\"]\\`      | \\`v.array(values)\\`                              | Arrays can have at most 8192 values.\n                                                                              |\n| Object      | Object      | \\`{a: \"abc\"}\\`           | \\`v.object({property: value})\\`                  | Convex only supports \"plain old JavaScript objects\" (objects that do not have a custom prototype). Objects can have at most 1024 entries. Field names must be ASCII characters, nonempty, and not start with \"$\" or \"_\". |\n| Record      | Record      | \\`{\"a\": \"1\", \"b\": \"2\"}\\` | \\`v.record(keys, values)\\`                       | Records are objects at runtime, but can have dynamic keys. Keys must be only ASCII characters, nonempty, and not start with \"$\" or \"_\".\n\n- \\`v.object()\\`, \\`v.array()\\`, \\`v.boolean()\\`, \\`v.number()\\`, \\`v.string()\\`, \\`v.id()\\`, and \\`v.null()\\` are the most common\n  validators you'll need. Do NOT use any other validators. In particular, \\`v.map()\\` and \\`v.set()\\` are not supported.\n\n- Below is an example of an array validator:\n\n\\`\\`\\`ts\nimport { mutation } from \"./_generated/server\";\nimport { v } from \"convex/values\";\n\nexport default mutation({\n  args: {\n      simpleArray: v.array(v.union(v.string(), v.number())),\n  },\n  handler: async (ctx, args) => {\n      //...\n  },\n});\n\\`\\`\\`\n\n- Below is an example of a schema with validators that codify a discriminated union type:\n\\`\\`\\`ts\nimport { defineSchema, defineTable } from \"convex/server\";\nimport { v } from \"convex/values\";\n\nexport default defineSchema({\n    results: defineTable(\n        v.union(\n            v.object({\n                kind: v.literal(\"error\"),\n                errorMessage: v.string(),\n            }),\n            v.object({\n                kind: v.literal(\"success\"),\n                value: v.number(),\n            }),\n        ),\n    )\n});\n\\`\\`\\`\n\n- ALWAYS use argument validators. For example:\n\n\\`\\`\\`ts\nimport { mutation } from \"./_generated/server\";\nimport { v } from \"convex/values\";\n\nexport default mutation({\n  args: {\n    simpleArray: v.array(v.union(v.string(), v.number())),\n  },\n  handler: async (ctx, args) => {\n    //...\n  },\n});\n\\`\\`\\`\n\n- NEVER use return validators when getting started writing an app. For example:\n\n\\`\\`\\`ts\nimport { mutation } from \"./_generated/server\";\nimport { v } from \"convex/values\";\n\nexport default mutation({\n  args: {\n    simpleArray: v.array(v.union(v.string(), v.number())),\n  },\n  // Do NOT include a return validator with the \\`returns\\` field.\n  // returns: v.number(),\n  handler: async (ctx, args) => {\n    //...\n    return 100;\n  },\n});\n\\`\\`\\`\n\n### Function registration\n\n- Use \\`internalQuery\\`, \\`internalMutation\\`, and \\`internalAction\\` to register internal functions. These functions are private and aren't part of an app's API. They can only be called by other Convex functions. These functions are always imported from \\`./_generated/server\\`.\n- Use \\`query\\`, \\`mutation\\`, and \\`action\\` to register public functions. These functions are part of the public API and are exposed to the public Internet. Do NOT use \\`query\\`, \\`mutation\\`, or \\`action\\` to register sensitive internal functions that should be kept private.\n- You CANNOT register a function through the \\`api\\` or \\`internal\\` objects.\n- ALWAYS include argument validators for all Convex functions. This includes all of \\`query\\`, \\`internalQuery\\`, \\`mutation\\`, \\`internalMutation\\`, \\`action\\`, and \\`internalAction\\`.\n- If the JavaScript implementation of a Convex function doesn't have a return value, it implicitly returns \\`null\\`.\n\n### Function calling\n\n- Use \\`ctx.runQuery\\` to call a query from a query, mutation, or action.\n- Use \\`ctx.runMutation\\` to call a mutation from a mutation or action.\n- Use \\`ctx.runAction\\` to call an action from an action.\n- ONLY call an action from another action if you need to cross runtimes (e.g. from V8 to Node). Otherwise, pull out the shared code into a helper async function and call that directly instead.\n- Try to use as few calls from actions to queries and mutations as possible. Queries and mutations are transactions, so splitting logic up into multiple calls introduces the risk of race conditions.\n- All of these calls take in a \\`FunctionReference\\`. Do NOT try to pass the callee function directly into one of these calls.\n- When using \\`ctx.runQuery\\`, \\`ctx.runMutation\\`, or \\`ctx.runAction\\` to call a function in the same file, specify a type annotation on the return value to work around TypeScript circularity limitations. For example,\n\n\\`\\`\\`ts\nexport const f = query({\n  args: { name: v.string() },\n  handler: async (ctx, args) => {\n    return \"Hello \" + args.name;\n  },\n});\n\nexport const g = query({\n  args: {},\n  handler: async (ctx, args) => {\n    const result: string = await ctx.runQuery(api.example.f, { name: \"Bob\" });\n    return null;\n  },\n});\n\\`\\`\\`\n\n### Function references\n\n- Function references are pointers to registered Convex functions.\n- ALWAYS use the \\`api\\` object defined by the framework in \\`convex/_generated/api.ts\\` to call public functions registered with \\`query\\`, \\`mutation\\`, or \\`action\\`. You must import the \\`api\\` object in the same file when using it and it looks like:\n\n\\`\\`\\`ts\nimport { api } from \"./_generated/api\";\n\\`\\`\\`\n\n- ALWAYS use the \\`internal\\` object defined by the framework in \\`convex/_generated/api.ts\\` to call internal (or private) functions registered with \\`internalQuery\\`, \\`internalMutation\\`, or \\`internalAction\\`. You must import the \\`internal\\` object in the same file when using it and it looks like:\n\n\\`\\`\\`ts\nimport { internal } from \"./_generated/api\";\n\\`\\`\\`\n\n- Convex uses file-based routing, so a public function defined in \\`convex/example.ts\\` named \\`f\\` has a function reference of \\`api.example.f\\`.\n- A private function defined in \\`convex/example.ts\\` named \\`g\\` has a function reference of \\`internal.example.g\\`.\n- Functions can also registered within directories nested within the \\`convex/\\` folder. For example, a public function \\`h\\` defined in \\`convex/messages/access.ts\\` has a function reference of \\`api.messages.access.h\\`.\n\n### Api design\n\n- Convex uses file-based routing, so thoughtfully organize files with public query, mutation, or action functions within the \\`convex/\\` directory.\n- Use \\`query\\`, \\`mutation\\`, and \\`action\\` to define public functions.\n- Use \\`internalQuery\\`, \\`internalMutation\\`, and \\`internalAction\\` to define private, internal functions.\n\n### Limits\n\nTo keep performance fast, Convex puts limits on function calls and database records:\n\n- Queries, mutations, and actions can take in at most 8 MiB of data as arguments.\n- Queries, mutations, and actions can return at most 8 MiB of data as their return value.\n\n- Arrays in arguments, database records, and return values can have at most 8192 elements.\n- Objects in function arguments and return values must be valid Convex objects, so they can\n  only contain ASCII field names. ALWAYS remap non-ASCII characters like emoji to an\n  ASCII code before storing them in an object synced to Convex.\n- Objects and arrays can only be nested up to depth 16.\n- Database records must be smaller than 1MiB.\n\n- Queries and mutations can read up to 8MiB of data from the database.\n- Queries and mutations can read up to 16384 documents from the database.\n- Mutations can write up to 8MiB of data to the database.\n- Mutations can write up to 8192 documents to the database.\n\n- Queries and mutations can execute for at most 1 second.\n- Actions and HTTP actions can execute for at most 10 minutes.\n\n- HTTP actions have no limit on request body size but can stream out at most 20MiB of data.\n\nIMPORTANT: Hitting any of these limits will cause a function call to fail with an error. You\nMUST design your application to avoid hitting these limits. For example, if you are building\na stock ticker app, you can't store a database record for each stock ticker's price at a\npoint in time. Instead, download the data as JSON, save it to file storage, and have the app\ndownload the JSON file into the browser and render it client-side.\n\n### Environment variables\n\nConvex supports environment variables within function calls via \\`process.env\\`. Environment\nvariables are useful for storing secrets like API keys and other per-deployment configuration.\n\nYou can read environment variables from all functions, including queries, mutations, actions,\nand HTTP actions. For example:\n\n\\`\\`\\`ts\nimport { action } from \"./_generated/server\";\nimport OpenAI from \"openai\";\n\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n});\n\nexport const helloWorld = action({\n  args: {},\n  handler: async (ctx, args) => {\n    const completion = await openai.chat.completions.create({\n      model: \"gpt-4o-mini\",\n      messages: [{ role: \"user\", content: \"Hello, world!\" }],\n    });\n    return completion.choices[0].message.content;\n  },\n});\n\\`\\`\\`\n\n### Pagination\n\n- Paginated queries are queries that return a list of results in incremental pages.\n- You can define pagination using the following syntax:\n\n\\`\\`\\`ts\nimport { v } from \"convex/values\";\nimport { query, mutation } from \"./_generated/server\";\nimport { paginationOptsValidator } from \"convex/server\";\n\nexport const listWithExtraArg = query({\n  args: { paginationOpts: paginationOptsValidator, author: v.string() },\n  handler: async (ctx, args) => {\n    return await ctx.db\n      .query(\"messages\")\n      .withIndex(\"by_author\", (q) => q.eq(\"author\", args.author))\n      .order(\"desc\")\n      .paginate(args.paginationOpts);\n  },\n});\n\\`\\`\\`\n\nNote: \\`paginationOpts\\` is an object with the following properties:\n- \\`numItems\\`: the maximum number of documents to return (the validator is \\`v.number()\\`)\n- \\`cursor\\`: the cursor to use to fetch the next page of documents (the validator is \\`v.union(v.string(), v.null())\\`)\n\n- A query that ends in \\`.paginate()\\` returns an object that has the following properties: - page (contains an array of documents that you fetches) - isDone (a boolean that represents whether or not this is the last page of documents) - continueCursor (a string that represents the cursor to use to fetch the next page of documents)\n\n## Schema guidelines\n\n- Always define your schema in \\`convex/schema.ts\\`.\n- Always import the schema definition functions from \\`convex/server\\`:\n- System fields are automatically added to all documents and are prefixed with an underscore. The\n  two system fields that are automatically added to all documents are \\`_creationTime\\` which has\n  the validator \\`v.number()\\` and \\`_id\\` which has the validator \\`v.id(tableName)\\`.\n\n### Index definitions\n\n- Index names must be unique within a table.\n- The system provides two built-in indexes: \"by_id\" and \"by_creation_time.\" Never add these to the\n  schema definition of a table! They're automatic and adding them to will be an error. You cannot\n  use either of these names for your own indexes. \\`.index(\"by_creation_time\", [\"_creationTime\"])\\`\n  is ALWAYS wrong.\n- Convex automatically includes \\`_creationTime\\` as the final column in all indexes.\n- Do NOT under any circumstances include \\`_creationTime\\` as the last column in any index you define. This will result in an error.\n  \\`.index(\"by_author_and_creation_time\", [\"author\", \"_creationTime\"])\\` is ALWAYS wrong.\n- Always include all index fields in the index name. For example, if an index is defined as\n  \\`[\"field1\", \"field2\"]\\`, the index name should be \"by_field1_and_field2\".\n- Index fields must be queried in the same order they are defined. If you want to be able to\n  query by \"field1\" then \"field2\" and by \"field2\" then \"field1\", you must create separate indexes.\n- Index definitions MUST be nonempty. \\`.index(\"by_creation_time\", [])\\` is ALWAYS wrong.\n\nHere's an example of correctly using the built-in \\`by_creation_time\\` index:\nPath: \\`convex/schema.ts\\`\n\\`\\`\\`ts\nimport { defineSchema } from \"convex/server\";\n\nexport default defineSchema({\n  // IMPORTANT: No explicit \\`.index(\"by_creation_time\", [\"_creationTime\"]) \\` is needed.\n  messages: defineTable({\n    name: v.string(),\n    body: v.string(),\n  })\n    // IMPORTANT: This index sorts by \\`(name, _creationTime)\\`.\n    .index(\"by_name\", [\"name\"]),\n});\n\\`\\`\\`\nPath: \\`convex/messages.ts\\`\n\\`\\`\\`ts\nimport { query } from \"./_generated/server\";\n\nexport const exampleQuery = query({\n  args: {},\n  handler: async (ctx) => {\n    // This is automatically in ascending \\`_creationTime\\` order.\n    const recentMessages = await ctx.db.query(\"messages\")\n      .withIndex(\"by_creation_time\", (q) => q.gt(\"_creationTime\", Date.now() - 60 * 60 * 1000))\n      .collect();\n\n    // This is automatically in \\`_creationTime\\` order.\n    const allMessages = await ctx.db.query(\"messages\").order(\"desc\").collect();\n\n    // This query uses the index to filter by the name field and then implicitly\n    // orders by \\`_creationTime\\`.\n    const byName = await ctx.db.query(\"messages\")\n      .withIndex(\"by_name\", (q) => q.eq(\"name\", \"Alice\"))\n      .order(\"asc\")\n      .collect();\n  },\n});\n\\`\\`\\`\n\n## Typescript guidelines\n\n- You can use the helper typescript type \\`Id\\` imported from './_generated/dataModel' to get the type of the id for a given table. For example if there is a table called 'users' you can use \\`Id<'users'>\\` to get the type of the id for that table.\n- If you need to define a \\`Record\\` make sure that you correctly provide the type of the key and value in the type. For example a validator \\`v.record(v.id('users'), v.string())\\` would have the type \\`Record<Id<'users'>, string>\\`. Below is an example of using \\`Record\\` with an \\`Id\\` type in a query:\n\n\\`\\`\\`ts\nimport { query } from \"./_generated/server\";\nimport { Doc, Id } from \"./_generated/dataModel\";\n\nexport const exampleQuery = query({\n  args: { userIds: v.array(v.id(\"users\")) },\n  handler: async (ctx, args) => {\n    const idToUsername: Record<Id<\"users\">, string> = {};\n      for (const userId of args.userIds) {\n        const user = await ctx.db.get(userId);\n          if (user) {\n            users[user._id] = user.username;\n          }\n        }\n\n      return idToUsername;\n  },\n});\n\\`\\`\\`\n\n- Be strict with types, particularly around id's of documents. For example, if a function takes in an id for a document in the 'users' table, take in \\`Id<'users'>\\` rather than \\`string\\`.\n- Always use \\`as const\\` for string literals in discriminated union types.\n- When using the \\`Array\\` type, make sure to always define your arrays as \\`const array: Array<T> = [...];\\`\n- When using the \\`Record\\` type, make sure to always define your records as \\`const record: Record<KeyType, ValueType> = {...};\\`\n- Always add \\`@types/node\\` to your \\`package.json\\` when using any Node.js built-in modules.\n\n## Full text search guidelines\n\n### Defining a search index\nTo use full text search, you need to define a search index in the schema. \nEvery search index definition consists of:\n\n1. A name.\n   - Must be unique per table.\n2. A \\`searchField\\`\n   - This is the field which will be indexed for full text search.\n   - It must be of type \\`string\\`.\n3. [Optional] A list of \\`filterField\\`s\n   - These are additional fields that are indexed for fast equality filtering\n     within your search index.\n\nHere's an example of how to define a search index:\n\\`\\`\\`ts\nimport { defineSchema, defineTable } from \"convex/server\";\nimport { v } from \"convex/values\";\n\nexport default defineSchema({\n  messages: defineTable({\n    body: v.string(),\n    channel: v.string(),\n  }).searchIndex(\"search_body\", {\n    searchField: \"body\",\n    filterFields: [\"channel\"],\n  }),\n});\n\\`\\`\\`\nYou can specify search and filter fields on nested documents by using a dot-separated path like properties.name.\n\n### Querying with full text search\n\n- A query for \"10 messages in channel '#general' that best match the query 'hello hi' in their body\" would look like:\n\n\\`\\`\\`ts\nconst messages = await ctx.db\n  .query(\"messages\")\n  .withSearchIndex(\"search_body\", (q) =>\n    q.search(\"body\", \"hello hi\").eq(\"channel\", \"#general\"),\n  )\n  .take(10);\n\\`\\`\\`\n\n## Query guidelines\n\n- Do NOT use \\`filter\\` in queries. Instead, define an index in the schema and use \\`withIndex\\` instead.\n- Convex queries do NOT support \\`.delete()\\`. Instead, \\`.collect()\\` the results, iterate over them, and call \\`ctx.db.delete(row._id)\\` on each result.\n- Use \\`.unique()\\` to get a single document from a query. This method will throw an error if there are multiple documents that match the query.\n- When using async iteration, don't use \\`.collect()\\` or \\`.take(n)\\` on the result of a query. Instead, use the \\`for await (const row of query)\\` syntax.\n\n### Ordering\n\n- By default Convex always returns documents in ascending \\`_creationTime\\` order.\n- You can use \\`.order('asc')\\` or \\`.order('desc')\\` to pick whether a query is in ascending or descending order. If the order isn't specified, it defaults to ascending.\n- Document queries that use indexes will be ordered based on the columns in the index and can avoid slow table scans.\n\n## Mutation guidelines\n\n- Use \\`ctx.db.replace\\` to fully replace an existing document. This method will throw an error if the document does not exist.\n- Use \\`ctx.db.patch\\` to shallow merge updates into an existing document. This method will throw an error if the document does not exist.\n\n## Action guidelines\n\n- Always add \\`\"use node\";\\` to the top of files containing actions that use Node.js built-in modules.\n- Files that contain \\`\"use node\";\\` should NEVER contain mutations or queries, only actions. Node actions can only be called from the client or from other actions.\n- Never use \\`ctx.db\\` inside of an action. Actions don't have access to the database.\n- Below is an example of the syntax for an action:\n\n\\`\\`\\`ts\nimport { action } from \"./_generated/server\";\n\nexport const exampleAction = action({\n  args: {},\n  handler: async (ctx, args) => {\n    console.log(\"This action does not return anything\");\n    return null;\n  },\n});\n\\`\\`\\`\n\n## Scheduling guidelines\n\n### Cron guidelines\n\n- Only use the \\`crons.interval\\` or \\`crons.cron\\` methods to schedule cron jobs. Do NOT use the \\`crons.hourly\\`, \\`crons.daily\\`, or \\`crons.weekly\\` helpers.\n- Both cron methods take in a FunctionReference. Do NOT try to pass the function directly into one of these methods.\n- Define crons by declaring the top-level \\`crons\\` object, calling some methods on it, and then exporting it as default. For example,\n\n\\`\\`\\`ts\nimport { cronJobs } from \"convex/server\";\nimport { internal } from \"./_generated/api\";\nimport { internalAction } from \"./_generated/server\";\n\nconst empty = internalAction({\n  args: {},\n  handler: async (ctx, args) => {\n    console.log(\"empty\");\n  },\n});\n\nconst crons = cronJobs();\n\n// Run \\`internal.crons.empty\\` every two hours.\ncrons.interval(\"delete inactive users\", { hours: 2 }, internal.crons.empty, {});\n\nexport default crons;\n\\`\\`\\`\n\n- You can register Convex functions within \\`crons.ts\\` just like any other file.\n- If a cron calls an internal function, always import the \\`internal\\` object from \\`_generated/api\\`, even if the internal function is registered in the same file.\n\n### Scheduler guidelines\n\nYou can schedule a mutation or action to run in the future by calling\n\\`ctx.scheduler.runAfter(delay, functionReference, args)\\` from a\nmutation or action. Enqueuing a job to the scheduler is transactional\nfrom within a mutation.\n\nYou MUST use a function reference for the first argument to \\`runAfter\\`,\nnot a string or the function itself.\n\nAuth state does not propagate to scheduled jobs, so \\`getAuthUserId()\\` and\n\\`ctx.getUserIdentity()\\` will ALWAYS return \\`null\\` from within a scheduled\njob. Prefer using internal, privileged functions for scheduled jobs that don't\nneed to do access checks.\n\nScheduled jobs should be used sparingly and never called in a tight loop. Scheduled functions should not be scheduled more\nthan once every 10 seconds. Especially in things like a game simulation or something similar that needs many updates\nin a short period of time.\n\n## File storage guidelines\n\n- Convex includes file storage for large files like images, videos, and PDFs.\n- The \\`ctx.storage.getUrl()\\` method returns a signed URL for a given file. It returns \\`null\\` if the file doesn't exist.\n- Do NOT use the deprecated \\`ctx.storage.getMetadata\\` call for loading a file's metadata.\n- Do NOT store file urls in the database. Instead, store the file id in the database and query the \\`_storage\\` system table to get the url.\n- Images are stored as Convex storage IDs. Do NOT directly as image URLs. Instead, fetch the signed URL for each image from Convex\n  storage and use that as the image source.\n- Make sure to ALWAYS use the \\`_storage\\` system table to get the signed URL for a given file.\n\nInstead, query the \\`_storage\\` system table. For example, you can use \\`ctx.db.system.get\\` to get an \\`Id<\"_storage\">\\`.\n\n\\`\\`\\`ts\nimport { query } from \"./_generated/server\";\nimport { Id } from \"./_generated/dataModel\";\n\ntype FileMetadata = {\n  _id: Id<\"_storage\">;\n  _creationTime: number;\n  contentType?: string;\n  sha256: string;\n  size: number;\n}\n\nexport const exampleQuery = query({\n  args: { fileId: v.id(\"_storage\") },\n  handler: async (ctx, args) => {\n    const metadata: FileMetadata | null = await ctx.db.system.get(args.fileId);\n    console.log(metadata);\n    return null;\n  },\n});\n\\`\\`\\`\n\n- Convex storage stores items as \\`Blob\\` objects. You must convert all items to/from a \\`Blob\\` when using Convex storage.\n\n# Examples\n## Example of using Convex storage within a chat app\n\nThis example creates a mutation to generate a short-lived upload URL and a mutation to save an image message to the database. This mutation is called from the client, which uses the generated upload URL to upload an image to Convex storage. Then,\nit gets the storage id from the response of the upload and saves it to the database with the \\`sendImage\\` mutation. On the frontend, it uses the \\`list\\` query to get the messages from the database and display them in the UI. In this query, the\nbackend grabs the url from the storage system table and returns it to the client which shows the images in the UI. You should use this pattern for any file upload. To keep track of files, you should save the storage id in the database.\n\nPath: \\`convex/messages.ts\\`\n\\`\\`\\`ts\nimport { v } from \"convex/values\";\nimport { query } from \"./_generated/server\";\n\nexport const list = query({\n  args: {},\n  handler: async (ctx) => {\n    const messages = await ctx.db.query(\"messages\").collect();\n    return Promise.all(\n      messages.map(async (message) => ({\n        ...message,\n        // If the message is an \"image\" its \"body\" is an \\`Id<\"_storage\">\\`\n        ...(message.format === \"image\"\n          ? { url: await ctx.storage.getUrl(message.body) }\n          : {}),\n      })),\n    );\n  },\n});\n\nimport { mutation } from \"./_generated/server\";\n\nexport const generateUploadUrl = mutation({\n  handler: async (ctx) => {\n    return await ctx.storage.generateUploadUrl();\n  },\n});\n\nexport const sendImage = mutation({\n  args: { storageId: v.id(\"_storage\"), author: v.string() },\n  handler: async (ctx, args) => {\n    await ctx.db.insert(\"messages\", {\n      body: args.storageId,\n      author: args.author,\n      format: \"image\",\n    });\n  },\n});\n\nexport const sendMessage = mutation({\n  args: { body: v.string(), author: v.string() },\n  handler: async (ctx, args) => {\n    const { body, author } = args;\n    await ctx.db.insert(\"messages\", { body, author, format: \"text\" });\n  },\n});\n\\`\\`\\`\n\nPath: \\`src/App.tsx\\`\n\\`\\`\\`ts\nimport { FormEvent, useRef, useState } from \"react\";\nimport { useMutation, useQuery } from \"convex/react\";\nimport { api } from \"../convex/_generated/api\";\n\nexport default function App() {\n  const messages = useQuery(api.messages.list) || [];\n\n  const [newMessageText, setNewMessageText] = useState(\"\");\n  const sendMessage = useMutation(api.messages.sendMessage);\n\n  const [name] = useState(() => \"User \" + Math.floor(Math.random() * 10000));\n  async function handleSendMessage(event: FormEvent) {\n    event.preventDefault();\n    if (newMessageText) {\n      await sendMessage({ body: newMessageText, author: name });\n    }\n    setNewMessageText(\"\");\n  }\n\n  const generateUploadUrl = useMutation(api.messages.generateUploadUrl);\n  const sendImage = useMutation(api.messages.sendImage);\n\n  const imageInput = useRef<HTMLInputElement>(null);\n  const [selectedImage, setSelectedImage] = useState<File | null>(null);\n\n  async function handleSendImage(event: FormEvent) {\n    event.preventDefault();\n\n    // Step 1: Get a short-lived upload URL\n    const postUrl = await generateUploadUrl();\n    // Step 2: POST the file to the URL\n    const result = await fetch(postUrl, {\n      method: \"POST\",\n      headers: { \"Content-Type\": selectedImage!.type },\n      body: selectedImage,\n    });\n    const json = await result.json();\n    if (!result.ok) {\n      throw new Error(\\`Upload failed: \\${JSON.stringify(json)}\\`);\n    }\n    const { storageId } = json;\n    // Step 3: Save the newly allocated storage id to the database\n    await sendImage({ storageId, author: name });\n\n    setSelectedImage(null);\n    imageInput.current!.value = \"\";\n  }\n\n  return (\n    <main>\n      <h1>Convex Chat</h1>\n      <p className=\"badge\">\n        <span>{name}</span>\n      </p>\n      <ul>\n        {messages.map((message) => (\n          <li key={message._id}>\n            <span>{message.author}:</span>\n            {message.format === \"image\" ? (\n              <Image message={message} />\n            ) : (\n              <span>{message.body}</span>\n            )}\n            <span>{new Date(message._creationTime).toLocaleTimeString()}</span>\n          </li>\n        ))}\n      </ul>\n      <form onSubmit={handleSendMessage}>\n        <input\n          value={newMessageText}\n          onChange={(event) => setNewMessageText(event.target.value)}\n          placeholder=\"Write a message\u2026\"\n        />\n        <input type=\"submit\" value=\"Send\" disabled={!newMessageText} />\n      </form>\n      <form onSubmit={handleSendImage}>\n        <input\n          type=\"file\"\n          accept=\"image/*\"\n          ref={imageInput}\n          onChange={(event) => setSelectedImage(event.target.files![0])}\n          className=\"ms-2 btn btn-primary\"\n          disabled={selectedImage !== null}\n        />\n        <input\n          type=\"submit\"\n          value=\"Send Image\"\n          disabled={selectedImage === null}\n        />\n      </form>\n    </main>\n  );\n}\n\nfunction Image({ message }: { message: { url: string } }) {\n  return <img src={message.url} height=\"300px\" width=\"auto\" />;\n}\n\\`\\`\\`\n\n## Example of a real-time chat application with AI responses\n\nPath: \\`convex/functions.ts\\`\n\\`\\`\\`ts\nimport {\n  query,\n  mutation,\n  internalQuery,\n  internalMutation,\n  internalAction,\n} from \"./_generated/server\";\nimport { v } from \"convex/values\";\nimport OpenAI from \"openai\";\nimport { internal } from \"./_generated/api\";\nimport { getAuthUserId } from \"@convex-dev/auth/server\";\n\nasync function getLoggedInUser(ctx: QueryCtx) {\n  const userId = await getAuthUserId(ctx);\n  if (!userId) {\n    throw new Error(\"User not found\");\n  }\n  const user = await ctx.db.get(userId);\n  if (!user) {\n    throw new Error(\"User not found\");\n  }\n  return user;\n}\n\n/**\n * Create a channel with a given name.\n */\nexport const createChannel = mutation({\n  args: {\n    name: v.string(),\n  },\n  handler: async (ctx, args) => {\n    await getLoggedInUser(ctx);\n    return await ctx.db.insert(\"channels\", { name: args.name });\n  },\n});\n\n/**\n * List the 10 most recent messages from a channel in descending creation order.\n */\nexport const listMessages = query({\n  args: {\n    channelId: v.id(\"channels\"),\n  },\n  handler: async (ctx, args) => {\n    await getLoggedInUser(ctx);\n    const messages = await ctx.db\n      .query(\"messages\")\n      .withIndex(\"by_channel_and_author\", (q) => q.eq(\"channelId\", args.channelId).eq(\"authorId\", args.authorId))\n      .order(\"desc\")\n      .take(10);\n    return messages;\n  },\n});\n\n/**\n List the 10 most recent messages from a specific user within a specific channel\n */\nexport const listMessagesByUser = query({\n  args: {\n    channelId: v.id(\"channels\"),\n    authorId: v.id(\"users\"),\n  },\n  handler: async (ctx, args) => {\n    await getLoggedInUser(ctx);\n    const messages = await ctx.db\n      .query(\"messages\")\n      .withIndex(\"by_channel_and_author\", (q) => q.eq(\"channelId\", args.channelId).eq(\"authorId\", args.authorId))\n      .order(\"desc\")\n      .take(10);\n    return messages;\n  },\n});\n\n/**\n * Send a message to a channel and schedule a response from the AI.\n */\nexport const sendMessage = mutation({\n  args: {\n    channelId: v.id(\"channels\"),\n    authorId: v.id(\"users\"),\n    content: v.string(),\n  },\n  handler: async (ctx, args) => {\n    await getLoggedInUser(ctx);\n    const channel = await ctx.db.get(args.channelId);\n    if (!channel) {\n      throw new Error(\"Channel not found\");\n    }\n    const user = await ctx.db.get(args.authorId);\n    if (!user) {\n      throw new Error(\"User not found\");\n    }\n    await ctx.db.insert(\"messages\", {\n      channelId: args.channelId,\n      authorId: args.authorId,\n      content: args.content,\n    });\n    await ctx.scheduler.runAfter(0, internal.functions.generateResponse, {\n      channelId: args.channelId,\n    });\n    return null;\n  },\n});\n\nconst openai = new OpenAI();\n\nexport const generateResponse = internalAction({\n  args: {\n    channelId: v.id(\"channels\"),\n  },\n  handler: async (ctx, args) => {\n    // IMPORTANT: Auth isn't available in \\`generateResponse\\` since\n    // it's called by the scheduler.\n    const context = await ctx.runQuery(internal.functions.loadContext, {\n      channelId: args.channelId,\n    });\n    const response = await openai.chat.completions.create({\n      model: \"gpt-4o-mini\",\n      messages: context,\n    });\n    const content = response.choices[0].message.content;\n    if (!content) {\n      throw new Error(\"No content in response\");\n    }\n    await ctx.runMutation(internal.functions.writeAgentResponse, {\n      channelId: args.channelId,\n      content,\n    });\n    return null;\n  },\n});\n\nexport const loadContext = internalQuery({\n  args: {\n    channelId: v.id(\"channels\"),\n  },\n  handler: async (ctx, args) => {\n    const channel = await ctx.db.get(args.channelId);\n    if (!channel) {\n      throw new Error(\"Channel not found\");\n    }\n    const messages = await ctx.db\n      .query(\"messages\")\n      .withIndex(\"by_channel_and_author\", (q) => q.eq(\"channelId\", args.channelId).eq(\"authorId\", args.authorId))\n      .order(\"desc\")\n      .take(10);\n\n    const result = [];\n    for (const message of messages) {\n      if (message.authorId) {\n        const user = await ctx.db.get(message.authorId);\n        if (!user) {\n          throw new Error(\"User not found\");\n        }\n        result.push({\n          role: \"user\" as const,\n          content: \\`\\${user.name}: \\${message.content}\\`,\n        });\n      } else {\n        result.push({ role: \"assistant\" as const, content: message.content });\n      }\n    }\n    return result;\n  },\n});\n\nexport const writeAgentResponse = internalMutation({\n  args: {\n    channelId: v.id(\"channels\"),\n    content: v.string(),\n  },\n  handler: async (ctx, args) => {\n    await ctx.db.insert(\"messages\", {\n      channelId: args.channelId,\n      content: args.content,\n    });\n    return null;\n  },\n});\n\\`\\`\\`\n\nPath: \\`convex/schema.ts\\`\n\\`\\`\\`ts\nimport { defineSchema, defineTable } from \"convex/server\";\nimport { v } from \"convex/values\";\nimport { authTables } from \"@convex-dev/auth/server\";\n\nconst applicationTables = {\n  channels: defineTable({\n    name: v.string(),\n  }),\n\n  messages: defineTable({\n    channelId: v.id(\"channels\"),\n    authorId: v.optional(v.id(\"users\")),\n    content: v.string(),\n  }).index(\"by_channel_and_author\", [\"channelId\", \"authorId\"]),\n};\n\nexport default defineSchema({\n  ...authTables,\n  ...applicationTables,\n});\n\\`\\`\\`\n\n# Convex Components\nConvex Components package up code and data in a sandbox that allows you to confidently and quickly add new features to your backend.\nConvex Components are like mini self-contained Convex backends, and installing them is always safe. They can't read your app's tables or call your app's functions unless you pass them in explicitly.\nEach component is installed as its own independent library from NPM. You also need to add a \\`convex.config.ts\\` file that includes the component.\nALWAYS prefer using a component for a feature than writing the code yourself, unless the component is not yet supported.\nALWAYS use the \\`lookupDocs\\` tool to lookup documentation for a component before trying to use the \\`npmInstall\\` tool to install the relevant dependencies.\nYou DO NOT need to deploy a component to use it. You can use it after you've installed it. You can use multiple components in the same project.\n\nConvex has the following components:\n- \\`proseMirror\\`: A collaborative text editor component.\n- \\`presence\\`: A component for managing presence functionality, i.e., a live-updating list of users in a \"room\" including their status for when they were last online.\n\n",
  "isPublic": true,
  "logoStorageId": "kg23f373m9zzz9kptcdeq65gjs7t4acs",
  "logoUrl": "https://tacit-capybara-732.convex.cloud/api/storage/701cabfc-9a45-432a-91f7-bcea7337cfb0",
  "mcpServers": [],
  "name": "Convex for Expo",
  "popularity": 9.0,
  "tags": [
    "convex",
    "expo"
  ],
  "updatedAt": 1761386525134.0,
  "usageCount": 11.0,
  "userId": "user_30mlLem6xz7dBn7sqJNMUozNjBR"
}